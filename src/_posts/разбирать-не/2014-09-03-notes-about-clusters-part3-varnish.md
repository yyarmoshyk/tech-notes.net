---
id: 1629
title: 'Размышления о кластеризации: Часть 3 - Varnish кэш'
date: 2014-09-03T07:44:27+00:00
author: admin

guid: http://www.tech-notes.net/?p=1629
permalink: /notes-about-clusters-part3-varnish/
image: /wp-content/uploads/2014/08/cluster_logo.jpg
categories:
  - Clusters
  - Varnish
---
Собрался в конце концов с мыслями для того что бы продолжить демагогию о том, как же еще усложнить себе жизнь и уменьшить нагрузку на сервер.

Предыдущие статьи:  
[Размышления о кластеризации: Часть 1](http://www.tech-notes.net/notes-about-clusters/ "Размышления о кластеризации. Часть 1")  
[Размышления о кластеризации: Часть 2](http://www.tech-notes.net/notes-about-clusters-part2/ "Размышления о кластеризации: Часть 2")

В этой статье я хочу поговорить про кэш. Varnish - замечательный инструмент для кэширования Вашего сайта. Естественно при правильном подходе. Многие наивно полагают, что нужно кешировать все, что только можно. Они очень сильно ошибаются. Как правило Varnish хранит кэш в огроменном файле на диске, либо в оперативной памяти. Оперативная память - ресурс ограниченный, поэтому довольно глупо в нем хранить статический данные. Ну а на поиск хэша объекта в огромном файле уйдет времени больше, чем на то что бы выдать его с app/web сервера. Именно поэтому очень часто я вижу криво настроенные Varnishы, которые только создают дополнительную нагрузку на сервера, без ризонного прироста производительности.

К чему я эту демагогию развел? Потому что дальше речь пойдет о добавлении в уже существующий кластер еще одного сервера, который будет не только рулить трафик, но и кэшировать динамический контент.

Общая идея такая:  
Varnish вертится на отдельном сервере. IP адресом этого сервера резолвится доменное имя сайта. Если страница найдена в кэше - она выдается посетителю, если не найдена - отправляется запрос на web сервер, с дальнейшим созданием кешированой версии страницы. Статический контент отдается с app сервера.

Схема (№1) кластера выглядит следующим образом:  
[<img src="/wp-content/uploads/2014/09/Screenshot-from-2014-09-26-122037.png" alt="Screenshot from 2014-09-26 12:20:37" width="520" height="632" class="aligncenter size-full wp-image-1824" srcset="/wp-content/uploads/2014/09/Screenshot-from-2014-09-26-122037.png 520w, /wp-content/uploads/2014/09/Screenshot-from-2014-09-26-122037-139x170.png 139w, /wp-content/uploads/2014/09/Screenshot-from-2014-09-26-122037-246x300.png 246w" sizes="(max-width: 520px) 100vw, 520px" />](/wp-content/uploads/2014/09/Screenshot-from-2014-09-26-122037.png)

Можно рассматривать и вот такую (схема №2):  
[<img src="/wp-content/uploads/2014/09/Screenshot-from-2014-09-26-121924.png" alt="Screenshot from 2014-09-26 12:19:24" width="542" height="641" class="aligncenter size-full wp-image-1823" srcset="/wp-content/uploads/2014/09/Screenshot-from-2014-09-26-121924.png 542w, /wp-content/uploads/2014/09/Screenshot-from-2014-09-26-121924-143x170.png 143w, /wp-content/uploads/2014/09/Screenshot-from-2014-09-26-121924-253x300.png 253w" sizes="(max-width: 542px) 100vw, 542px" />](/wp-content/uploads/2014/09/Screenshot-from-2014-09-26-121924.png)

Отдельный сервер для Varnish нужен поскольку кэш предлагается хранить в оперативной памяти. Это ускорит скорость ответа в 5-10 раз, что не может не сказаться положительно на общем SEO рейтинге Вашего web-ресурса. Поскольку я рассматриваю гипотетическую ситуацию, когда web сервер перестал выдерживать наплыв посетителей, то не имеет смысла обратно нагружать этот же web сервер еще и Varnish&#8217;ом.

Как правило нету смысла нагружать Varnish сервер еще и обработкой трафика для app сервера, все же статический контент имеет на много большие объемы и соответственно требует больше процессорного времени. Поэтому первую схему стоит рассматривать только если у Вас по каким-то причинам не работает трюк с Rewrite, который я описывал в [предыдущей части](http://www.tech-notes.net/notes-about-clusters-part2/ "Размышления о кластеризации: Часть 2")

Для того, что бы настроить Varnish можно воспользоваться [соответствующей статьей](http://www.tech-notes.net/varnish-configuration-rewiev/ "Обзор конфигурации Varnish").

В принципе статью с обзором конфигурации Varnish можно использовать как опорную и ее будет достаточно для корректной работы. Рекомендую провести анализ страниц вашего сайта и определиться какие из них все же стоит исключить из кеширования, а для каких установить меньшее время хранения кэша.

Если у Вас блог, который обновляется раз в день, то можно не заморачиваться. Время хранения кэша определяется директивой beresp.ttl в vcl_fetch. В [статье](http://www.tech-notes.net/varnish-configuration-rewiev/ "Обзор конфигурации Varnish") для примера он приведен со значением 86400 секунд = 24 часа. Теоретически кэш будет очищен перед тем, как Вы опубликуете новые материалы.

Если же некоторые страницы Вашего ресурса обновляются в произвольный момент времени несколько раз в день, тогда есть смысл исключить их из кеширования с помощью следующей конструкции в vcl_recv:

```bash
if (req.url == "^/(uri_1|uri_3|uri_3)") {
        return (pass);
    }
```


Также рекомендую создать страницу, которая позволит Вам очищать кэш Varnish. Можно воспользоваться [соответствующей заметкой](http://www.tech-notes.net/flush-varnish-cache-browser-php/ "Очистка кэша Varnish через Браузер с помощью PHP")

Эту страницу нужно разместить на web сервере, отключить для нее кеширование, а в acl purge добавить ip адрес с которым Varnish видит web сервер.

Взяв эту статью за основу можно изменить код Вашего сайта и добавить в него вызов очистки кєша Varnish при добавлении, скажем, комментария к статье. Имеется ввиду удаление из кэша объекта статьи, к которой был добавлен комментарий. 

До сих пор я не добавил web серверов в кластер. В следующих статьях речь пойдет о них.

<div style="padding-bottom:20px; padding-top:10px;" class="hupso-share-buttons">
  <!-- Hupso Share Buttons - http://www.hupso.com/share/ -->
  
  <a class="hupso_pop" href="http://www.hupso.com/share/"><img src="http://static.hupso.com/share/buttons/button120x28.png" style="border:0px; width:120; height: 28; " alt="Share Button" /></a><!-- Hupso Share Buttons -->
</div>