---
id: 869
title: Интересные приемы программирования на Bash
date: 2014-07-12T02:29:21+00:00
author: admin

guid: http://www.tech-notes.net/?p=869
permalink: /bash-progarming-examples/
image: /wp-content/uploads/2014/02/bash_shell.jpg
categories:
  - bash
tags:
  - FromHabrSandbox
  - функции bash
---
Эти приемы были описаны во внутреннем проекте компании Google «Testing on the Toilet» (Тестируем в туалете — распространение листовок в туалетах, что бы напоминать разработчикам о тестах).  
В данной статье они были пересмотрены и дополнены.

### Безопасность

Я начинаю каждый скрипт со следующих строк

```bash
#!/bin/bash
set -o nounset
set -o errexit
```


Это защищает от двух частых ошибок

  1.  Попыток использовать не объявленные переменные
  2.  Игнорирование аварийного завершения команд

Если команда может завершиться аварийно, и нас это устраивает, можно использовать следующий код:

```bash
if ! ; then
  echo "failure ignored"
fi
```


Нужно помнить что некоторые команды не возвращают код аварийного завершения например “`mkdir -p`” и “`rm -f`”.

Так же есть сложности с вызовом цепочек подпрограмм (command1 | command 2 | command3) из скрипта, для обхода этого ограничения можно использовать следующую конструкцию:

```bash
(./failing_command && echo A)
```

В этом случае оператор '&&' не позволит выполниться следующей команде, подробнее — [Bash: Error_handling](http://fvue.nl/wiki/Bash:_Error_handling)

<center>
  <div id="gads">
  </div>
</center>

### Функции

Bash позволяет использовать функции как обычные команды, это очень сильно повышает читаемость вашего кода:  
**Пример 1:**

```bash
ExtractBashComments() {
	egrep "^#"
}
cat myscript.sh | ExtractBashComments | wc

comments=$(ExtractBashComments < myscript.sh)
```


**Пример 2:**

```bash
SumLines() { # iterating over stdin - similar to awk
	local sum=0
	local line=””
	while read line ; do
		sum=$((${sum} + ${line}))
	done
	echo ${sum}
}
SumLines < data_one_number_per_line.txt
```


**Пример 3:**

```bash
log() {
	# classic logger
	local prefix="[$(date +%Y/%m/%d\ %H:%M:%S)]: "
	echo "${prefix} $@" >&2
}
log "INFO" "a message"
```


Попробуйте перенести весь ваш код в функции оставив только глобальные переменные/константы и вызов функции «main» в которой будет вся высокоуровневая логика.

<center>
  <div id="gads">
  </div>
</center>

### Объявление переменных

Bash позволяет объявлять переменные нескольких типов, самые важные:

  * local (Для переменных используемых только внутри функций)
  * readonly (Переменные попытка переназначения которых вызывает ошибку)

```bash
## Если DEFAULT_VAL уже объявлена, то использовать ее значение, иначе использовать '-7'
readonly DEFAULT_VAL=${DEFAULT_VAL:-7}

myfunc() {
	# Использование локальной переменной со значением глобальной
	local some_var=${DEFAULT_VAL}
	...
}
```


Есть возможность сделать переменную типа readonly из уже объявленной:

```bash
x=5
x=6
readonly x
x=7 # failure
```


Стремитесь к тому что бы все ваши переменные были либо local, либо readonly, это улучшит читаемость и снизит количество ошибок.

**Используйте `$()` вместо обратных кавычек ` `` `**

Обратные кавычки плохо читаются и в некоторых шрифтах легко могут быть перепутаны с одинарными кавычками.  
Конструкция $() так же позволяет использовать вложенные вызовы без головной боли с экранированием:

```bash
# обе команды выводят: A-B-C-D
echo "A-`echo B-\`echo C-\\\`echo D\\\`\``"
echo "A-$(echo B-$(echo C-$(echo D)))"
```


**Используйте двойные квадратные скобки `[[]]` вместо одинарных `[]`**

Двойные квадратные скобки позволяют избежать непреднамеренного использования путей вместо переменных:

```bash
$ [ a < b ]
-bash: b: No such file or directory
$ [[ a < b ]]
```


В некоторых случаях упрощают синтаксис:

```bash
[ "${name}" \> "a" -o ${name} \< "m" ] [[ "${name}" > "a" && "${name}" < "m" ]]
```


А так же предоставляют дополнительную функциональность:

**Новые операторы**:
  * **||** Логическое ИЛИ (logical or) — только с двойными скобками.
  * **&&** Логическое И (logical and) — только с двойными скобками.
  * **<** Сравнение строковых переменных (string comparison) — с двойными скобками экранирование не нужно.
  * **==** Сравнение строковых переменных с подстановкой (string matching with globbing) — только с двойными скобками.
  * **=~** Сравнение строковых переменных используя регулярные выражения (string matching with regular expressions) — только с двойными скобками.

Дополненные/измененные операторы:
  * **-lt** Цифровое сравнение (numerical comparison)
  * **-n** Строковая переменная не пуста (string is non-empty)
  * **-z** Строковая переменная пуста (string is empty)
  * **-eq** Цифровое равенство (numerical equality)
  * **-ne** Цифровое не равенство (numerical inequality)

Примеры:

```bash
t="abc123"
[[ "$t" == abc* ]] # true (globbing)
[[ "$t" == "abc*" ]] # false (literal matching)
[[ "$t" =~ [abc]+[123]+ ]] # true (regular expression)
[[ "$t" =~ "abc*" ]] # false (literal matching)
```


Начиная с версии bash 3.2 регулярные выражения или выражения с подстановкой не должны заключаться в кавычки, если ваше выражение содержит пробелы, вы можете поместить его в пеерменную:

```bash
r="a b+"
[[ "a bbb" =~ $r ]] # true
```


Сравнение строковых переменных с подстановкой так же доступно в операторе case:

```bash
case $t in
abc*) ;;
esac
```


<center>
  <div id="gads">
  </div>
</center>

### Работа со строковыми переменными:

В bash встроено несколько (недооцененных) возможностей работы со строковыми переменными:  
**Базовые**:

```bash
f="path1/path2/file.ext"
len="${#f}" # = 20 (длина строковой переменной)
# выделение участка из переменной: ${<переменная>:<начало_участка>} или ${<переменная>:<начало_участка>:<размер_участка>}
slice1="${f:6}" # = "path2/file.ext"
slice2="${f:6:5}" # = "path2"
slice3="${f: -8}" # = "file.ext" #(обратите внимание на пробел перед знаком '-')
pos=6
len=5
slice4="${f:${pos}:${len}}" # = "path2"
```


**Замена с подстановкой**:

```bash
f="path1/path2/file.ext"
single_subst="${f/path?/x}" # = "x/path2/file.ext" #(замена первого совпадения)
global_subst="${f//path?/x}" # = "x/x/file.ext" #(замена всех совпадений)
```


**Разделение переменных**:

```bash
f="path1/path2/file.ext"
readonly DIR_SEP="/"
array=(${f//${DIR_SEP}/ })
second_dir="${arrray[1]}" # = path2
```


**Удаление с подстановкой**:

```bash
# Удаление с начала строки, до первого совпадения
f="path1/path2/file.ext"
extension="${f#*.}" # = "ext"
```


**Удаление с начала строки, до последнего совпадения**

```bash
f="path1/path2/file.ext"
filename="${f##*/}" # = "file.ext"
```


**Удаление с конца строки, до первого совпадения**

```bash
f="path1/path2/file.ext"
dirname="${f%/*}" # = "path1/path2"
```


**Удаление с конца строки, до последнего совпадения**

```bash
f="path1/path2/file.ext"
root="${f%%/*}" # = "path1"
```


<center>
  <div id="gads">
  </div>
</center>

### Избавляемся от временных файлов

Некоторые команды ожидают на вход имя файла, с ними нам поможет оператор '<()', он принимает на вход команду и преобразует в нечто что можно использовать как имя файла:

```bash
# скачать два URLa и передать их в diff
diff <(wget -O - url1) <(wget -O - url2)
```


Использование маркера для передачи многострочных переменных:

```bash
# MARKER — любое слово.
command << MARKER
...
${var}
$(cmd)
...
MARKER
```


Если нужно избежать подстановки, то маркер можно взять в кавычки:

```bash
# конструкция вернет '$var' а не значение переменной
var="text"
cat << 'MARKER'
...
$var
...
MARKER
```


<center>
  <div id="gads">
  </div>
</center>

### Встроенные переменные

  * **$0** Имя скрипта (name of the script)
  * **$1 $2… $n** Параметры переданные скрипту/функции (positional parameters to script/function)
  * **$$** PID скрипта (PID of the script)
  * **$!** PID последней команды выполненной в фоне(PID of the last command executed (and run in the background))
  * **$?** Статус возвращенный последней командой (exit status of the last command (${PIPESTATUS} for pipelined commands))
  * **$#** Количество параметров переданных скрипту/функции (number of parameters to script/function)
  * **$@** Все параметры переданные скрипту/функции, представленные в виде слов (sees arguments as separate word)
  * **$*** Все параметры переданные скрипту/функции, представленные в виде одного слова (sees arguments as single word)

Как правило:

  * **$*** Редко является полезной
  * **$@** Корректно обрабатывает пустые параметры и параметры с пробелами
  * **$@** При использовании обычно заключается в двойные кавычки — `$@`

**Пример**:

```bash
for i in "$@"; do echo '$@ param:' $i; done

for i in "$*"; do echo '$! param:' $i; done
```


вывод:

```bash
bash ./parameters.sh arg1 arg2  
$@ param: arg1  
$@ param: arg2  
$! param: arg1 arg2
```

<center>
  <div id="gads">
  </div>
</center>

### Отладка

Проверка синтаксиса (экономит время если скрипт выполняется дольше 15 секунд):

```bash
bash -n myscript.sh
```

Трассировка:

```bash
bash -v myscripts.sh
```

Трассировка с раскрытием сложных команд:

```bash
bash -x myscript.sh
```

Параметры -v и -x можно задать в коде, это может быть полезно если ваш скрипт работает на одной машине а журналирование ведется на другой:

```bash
set -o verbose
set -o xtrace
```


Признаки того, что вы не должны использовать shell скрипты:
  * Ваш скрипт содержит более нескольких сотен строк.
  * Вам нужны структуры данных сложнее обычных массивов.
  * Вас задолбало заниматься непотребствами с кавычками и экранированием.
  * Вам необходимо обрабатывать/изменять много строковых переменных.
  * У вас нет необходимости вызывать сторонние программы и нет необходимости в папках.
  * Для вас важна скорость/производительность.

Если ваш проект соответствует пунктам из этого списка, рассмотрите для него языки языки Python или Ruby.

Ссылки:  
* [Advanced Bash-Scripting Guide](http://tldp.org/LDP/abs/html/)  
* [Bash Reference Manual](http://www.gnu.org/software/bash/manual/bashref.html)
* [Оригинал статьи](http://robertmuth.blogspot.ru/2012/08/better-bash-scripting-in-15-minutes.html):
* Взято (C) [habrahabr.ru](http://habrahabr.ru/post/221273/)
